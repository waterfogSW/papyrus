객체지향적인 개발을 하다 보면, 재사용성이나 유지보수성을 위해 책임과 역할에 따라 핵심기능을 쪼개는 경우가 많습니다. 이렇게 쪼개진 각 단위들에 대해서 부가적으로 적용이 되어야 하는 공통적인 기능이 생기게 되는데, 이를테면 로그, 트랜잭션, 락, 유효성검사 와 같은것들이 있습니다.

이렇게 공통적으로 적용을 해야하는 부가기능들을 각 단위별로 중복해서 구현하게 되면, 관리포인트가 많아지고, 비즈니스 로직에 집중하기 어려운 코드가 되기도 합니다. 이러한 문제점을 해결하기 위해서 핵심 기능들에 침투한 부가기능을 독립적인 모듈(Aspect)로 구분해 내고 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하게 만들 수 있습니다. 이러한 방식을 Aspect-Oriented Programming 이라고 합니다.

OOP는 객체를 중심으로 데이터와 기능을 캡슐화하고, 상속과 다형성을 통해 코드를 조직화하는 데 초점을 맞춥니다. 반면, AOP는 애플리케이션 전반에 걸쳐있는 관심사를 분리하고 모듈화하여, 코드의 중복을 줄이고 유지보수를 용이하게 하는 데 초점을 맞춥니다. AOP는 OOP를 대체하는 기술이 아니라, OOP를 보조하는 기술입니다.

## AOP 의 원리
![[Pasted image 20231227235512.png]]
AOP 는 주로 프록시 패턴을 활용해 구현됩니다. 클라이언트의 요청은 실제 객체를 향하는 것이 아니라 생성된 프록시 객체를 향하게 되고, 프록시 객체는 실제 객체의 핵심기능을 호출하고, 호출 전후에 부가기능을 수행하는 방식으로 동작하게 됩니다.
## 스프링 AOP

![[Pasted image 20231227211945.png]]

프록시를 활용한 AOP방식에는 두가지 방식이 있다. 하나는 JDK 의 다이나믹 프록시를 활용하는 방식이고, 하나는 CGLib 이라는 오픈소스 바이트코드 생성 프레임 워크를 이용해 프록시를 만드는 방식이다.

다이내믹 프록시는 리플렉션 기능을 이용해 특정 클래스의 인터페이스를 구현하는 프록시 객체를 만들어 준다. 자바의 모든 클래스는 해당 클래스의 구성정보를 가지고 있는 Class 타입의 오브젝트를 하나씩 가지고 있는데, 이 오브젝트를 통해 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다. 이때 클래스의 인터페이스를 확인하고 해당 인터페이스로 프록시 객체를 구현하는 것이다.

![[Pasted image 20231228161123.png]]

다이내믹 프록시는 프록시 팩토리에 의해 런타임에 동적으로 만들어진다. 이때 다이내믹 프록시의 오브젝트는 타깃 오브젝트의 인터페이스를 구현한다. 다이내믹 프록시는 모든 요청을 `InvocationHandler` 인터페이스를 구현한 오브젝트의 invoke() 메소드로 전달하고, invoke() 메소드는 실제 타킷 오브젝트의 메소드를 리플렉션 API를 통해 호출한다. 호출 전후로 부가기능을 수행한다.

요청을 위임할 타깃 오브젝트의 경우 스프링 빈으로 등록되어있다. 때문에 스프링의 DI로 제공받도록 하기 위해서는 InvocationHandler와 다이내믹 프록시를 스프링의 빈으로 등록해야 한다. 하지만, 다이내믹 프록시의 오브젝트는 동적으로 정의되기 때문에 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링의 빈에 정의할 순 없다.

이렇게 Proxy의 newProxyInstrance() 메서드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인방법으로는 스프링의 빈으로 등록할 수 없다. 이때 **팩토리 빈**을 사용하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어 줄 수가 있다.

하지만 이런 프록시 팩토리 빈 방식에도 한계가 있다. 부가기능이 하나의 타깃 오브젝트에만 부여되는 것이라면 상관 없겠지만, 트랜잭션과 같이 비즈니스 로직을 담은 많은 클래스의 메소드에 적용할 필요가 있다면, 프록시 팩토리 빈의 설정이 중복되는것을 막을 수 없다. 또한 타깃 오브젝트의 개수만큼 다른 빈으로 등록해야 하고, 그만큼 많은 오브젝트를 생성하게 된다.

이러한 문제점을 해결하기 위해 스프링은 ProxyFactoryBean을 제공한다. ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다. 순수하게 프록시를 생성하는 작업만을 담당하고, 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.

ProxyFactoryBean이 생성하는 부가기능은 MethodInterceptor인터페이스를 구현해서 만든다. InvocationHandler와 비슷하지만, ProxyFactoryBean으로 부터 타깃 오브젝트에 대한 정보를 함께 제공받기 때문에 타깃 오브젝트에 상관없이 독립적으로 만들어져 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로도 등록 가능하다.

ProxyFactoryBean는 InvocationHandler대신 MethodInterceptor를 구현하는데, MethodInterceptor에는 메서도 정보와 함께 타깃 오브젝트가 담긴 MethodInvocation 오브젝트가 전달된다. MethodInvocation은 일종의 콜백 오브젝트로, proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행한다. 

어드바이저 = 어드바이스(순수 부가기능) + 포인트컷(부가 기능 적용대상 메소드 선정방법)

AspectJ 포인트컷 표현식을 활용하는 포인트컷은 스트링으로 된 표현식을 담은 expression 프로퍼티 하나만 설정해주면 사용할 수 있다.
## AOP 를 적용한 기술

- 프록시
- 